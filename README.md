# deep-copy
Маленькая утилита для копирования объектов. Реализована без использования сторонних библиотек, но в таком виде, чтобы ее можно было максимально быстро сделать, к примеру, Spring Bean-ом.

Для копирования использует наиболее жестокие возможности рефлексии, и потому, если у вас в программе установлен SecurityManager, ограничивающий вмешательство в приватные и финальные поля и конструкторы, утилита скорее всего окажется бесполезной.

# Использование
Класс DeepCopyUtil средствами рефлексии копирует переданные ему объекты вплоть до определенной глубины, задаваемой при помощи аннотаций (см. ниже). 
Чтобы сделать объект копируемым, существует два способа:
1. Пометить класс аннотацией @DeepCopyable, добавить ему конструктор без параметров и настроить уровень глубины копирования, расставив аннотации @CopyMode на его полях. Если поле не помечено аннотацией, выбор между копированием ссылки и копированием объекта делается исходя из того, способна ли утилита копировать объект этого типа.
2. Создать наследника класса CloneFactory, и зарегистрировать его как фабрику определенного типа объектов при помощи DeepCopyUtil.addCloneFactory(...). 

# Расширение функционала
Изначально, утилита поддерживает копирование некоторых классов-коллекций из стандартной библиотеки, таких как ArrayList, HashMap, HashSet и др. 
Список поддерживаемых библиотечных классов можно расширить, создав для них CloneFactory и зарегистрировав его для определенного класса. 

Важно: чтобы фабрика могла быть использована, класс объекта должен в точности совпадать с классом, для которого фабрика была зарегистрирована, фабрики родительских классов не используются для конструирования наследников!

Класс DeepCopyUtil, помимо обычного метода копирования, имеет еще два, с дополнительными параметрами:
- deepCopy(T src, Map<String, Object> params) позволяет передавать список параметров, которые затем можно будет извлечь в фабричном методе
- deepCopy(T src, Map<Object, Object> cloneReferences, Map<String, Object> params) добавляет параметр cloneReferences. Эту мапу используют для записи соответствий между оригинальными и скопированными объектами. Эта перегрузка предназначена, главным образом, для наследников CloneFactory.

# Возможности
Объекты, у которых нет аннотации @DeepCopyable и зарегистрированной фабрики, не копируются. Если утилита находит поле с таким объектом, она просто копирует ссылку на тот же самый объект.

Примитивные типы данных, обертки примитивных типов, строки, перечисления также всегда передаются без попыток их клонирования

Коллекции и массивы могут быть скопированы двумя способами - с сохранением тех же самых элементов, либо с копированием элементов. Для управления этим поведением используется параметр copyItems аннотации @CopyMode. 
Для реализаций Map в @CopyMode также имеется параметр copyKeys.

Если поле не нужно копировать, можно указать режим копирования Mode.SKIP, в таком случае в поле останется то значение, которое ему присвоит конструктор.

Рекомендуется с большой осторожностью применять утилиту при наличии внутренних не-статических классов, так как они имеют неявную ссылку на объект внешнего класса, для которого они были созданы, что может спровоцировать нежелательное копирование и объекта внешнего класса.
